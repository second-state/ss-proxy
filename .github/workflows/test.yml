name: Test

on:
  push:
    branches:
      - main
      - dev
      - release-*
      - feat-*
      - ci-*
      - refactor-*
      - fix-*
      - test-*
    paths:
      - '.github/workflows/test.yml'
      - '**/Cargo.toml'
      - '**/*.rs'
      - '**/*.hurl'
      - 'run_tests.sh'
      - 'test_streaming.sh'
      - 'tests/**'
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust: [1.90.0]

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Start httpbin
        run: |
          # Use official httpbin image
          docker run -d \
            --name httpbin \
            -p 8888:80 \
            kennethreitz/httpbin:latest

          # Wait for service to be ready
          echo "Waiting for httpbin to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:8888/get > /dev/null 2>&1; then
              echo "‚úÖ httpbin is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "‚ùå httpbin failed to start"
              docker logs httpbin
              exit 1
            fi
            sleep 2
          done

      - name: Start json-server
        run: |
          # Use Node.js official image to run json-server
          docker run -d \
            --name json-api \
            -p 8889:3000 \
            -v ${{ github.workspace }}/tests/mock-data:/data:ro \
            -w /data \
            node:18-alpine \
            sh -c "npm install -g json-server@0.17.4 && json-server --host 0.0.0.0 --port 3000 db.json"

          # Wait for service to be ready
          echo "Waiting for json-api to be ready..."
          for i in {1..60}; do
            if curl -f http://localhost:8889/posts > /dev/null 2>&1; then
              echo "‚úÖ json-api is ready!"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "‚ùå json-api failed to start"
              docker logs json-api
              exit 1
            fi
            sleep 2
          done

      - name: Start WebSocket echo server
        run: |
          # Use ultra-robust Python WebSocket echo server with manual message loop
          cat > ws-echo.py << 'EOF'
          import asyncio
          import websockets
          import logging
          import sys

          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              stream=sys.stdout
          )
          logger = logging.getLogger(__name__)

          async def echo(websocket):
              client_addr = websocket.remote_address
              logger.info(f"‚úÖ New connection from {client_addr}")

              message_count = 0
              try:
                  # Manual receive loop with explicit error checking
                  while True:
                      try:
                          # Wait for message with timeout
                          message = await asyncio.wait_for(
                              websocket.recv(),
                              timeout=60.0  # 60 second timeout
                          )

                          message_count += 1
                          msg_type = "binary" if isinstance(message, bytes) else "text"
                          msg_size = len(message)

                          logger.info(f"üì® Received {msg_type} message #{message_count}: {msg_size} bytes from {client_addr}")

                          # Echo back immediately
                          await websocket.send(message)
                          logger.info(f"üì§ Echoed {msg_type} message #{message_count}: {msg_size} bytes to {client_addr}")

                      except asyncio.TimeoutError:
                          logger.warning(f"‚è∞ Timeout waiting for message from {client_addr}")
                          continue
                      except websockets.exceptions.ConnectionClosedOK:
                          logger.info(f"‚úÖ Connection closed normally by {client_addr} after {message_count} messages")
                          break
                      except websockets.exceptions.ConnectionClosedError as e:
                          logger.warning(f"‚ö†Ô∏è  Connection closed with error from {client_addr}: {e}")
                          break

              except Exception as e:
                  logger.error(f"‚ùå Unexpected error handling {client_addr}: {e}", exc_info=True)
              finally:
                  logger.info(f"üîö Handler ended for {client_addr} (processed {message_count} messages)")

          async def main():
              host = "0.0.0.0"
              port = 8890

              logger.info(f"üöÄ Starting WebSocket echo server on {host}:{port}")

              # Start server with very permissive settings
              async with websockets.serve(
                  echo,
                  host,
                  port,
                  ping_interval=None,      # Disable ping/pong (let client handle it)
                  ping_timeout=None,       # No ping timeout
                  close_timeout=10,        # 10 seconds for close handshake
                  max_size=10 * 1024 * 1024,  # 10MB max message
                  max_queue=32,            # Max 32 queued messages
                  compression=None         # Disable compression for simplicity
              ):
                  logger.info(f"‚úÖ WebSocket echo server is ready and listening")
                  await asyncio.Future()  # Run forever

          if __name__ == "__main__":
              try:
                  asyncio.run(main())
              except KeyboardInterrupt:
                  logger.info("üõë Server stopped by user")
                  sys.exit(0)
          EOF

          docker run -d \
            --name ws-echo \
            -p 8890:8890 \
            -v ${{ github.workspace }}/ws-echo.py:/ws-echo.py:ro \
            python:3.11-alpine \
            sh -c "pip install websockets && python /ws-echo.py"

          # Wait for service to be ready - WebSocket service starts quickly
          echo "Waiting for ws-echo to be ready..."
          sleep 10

          # Check if container is running
          if docker ps | grep -q ws-echo; then
            echo "‚úÖ ws-echo container is running!"
          else
            echo "‚ùå ws-echo container failed to start"
            docker logs ws-echo
            exit 1
          fi

      - name: Install Rust-stable
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: ${{ matrix.rust }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          cache-on-failure: true

      - name: Install Hurl
        run: |
          VERSION="5.0.1"
          curl -LO https://github.com/Orange-OpenSource/hurl/releases/download/${VERSION}/hurl_${VERSION}_amd64.deb
          sudo dpkg -i hurl_${VERSION}_amd64.deb

      - name: Install SQLite
        run: sudo apt-get update && sudo apt-get install -y sqlite3

      - name: Verify services are running
        run: |
          echo "Checking httpbin..."
          curl -f http://localhost:8888/get

          echo "Checking json-api..."
          curl -f http://localhost:8889/posts

          echo "Checking ws-echo (WebSocket service - checking port)..."
          if timeout 5 bash -c 'cat < /dev/null > /dev/tcp/localhost/8890'; then
            echo "‚úÖ ws-echo port 8890 is listening"
          else
            echo "‚ùå ws-echo port 8890 is not accessible"
            docker logs ws-echo
            exit 1
          fi

      - name: Run tests
        env:
          USE_DOCKER_SERVICES: false  # Services already running via GitHub Actions
        run: |
          chmod +x run_tests.sh
          ./run_tests.sh

      - name: Upload test results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-logs
          path: |
            *.log
            sessions.db

      - name: Cleanup test services
        if: always()
        run: |
          docker stop httpbin || true
          docker rm httpbin || true
          docker stop json-api || true
          docker rm json-api || true
          docker stop ws-echo || true
          docker rm ws-echo || true

  streaming-test:
    name: Streaming Response Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust: [1.90.0]

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Rust-stable
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: ${{ matrix.rust }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          cache-on-failure: true

      - name: Install Python dependencies
        run: |
          python3 --version
          pip3 --version

      - name: Install SQLite
        run: sudo apt-get update && sudo apt-get install -y sqlite3

      - name: Install jq (for JSON parsing in tests)
        run: sudo apt-get install -y jq

      - name: Verify tools
        run: |
          echo "Rust version:"
          cargo --version
          rustc --version
          echo ""
          echo "Python version:"
          python3 --version
          echo ""
          echo "SQLite version:"
          sqlite3 --version
          echo ""
          echo "jq version:"
          jq --version

      - name: Run streaming tests
        env:
          CI: true
          TEST_PROXY_PORT: 8080
          TEST_MOCK_PORT: 10086
        run: |
          chmod +x test_streaming.sh
          ./test_streaming.sh

      - name: Upload test logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: streaming-test-logs
          path: |
            /tmp/proxy.log
            /tmp/mock-server.log
            test_streaming.db
          retention-days: 7

      - name: Display logs on failure
        if: failure()
        run: |
          echo "=== Proxy Logs ==="
          cat /tmp/proxy.log || echo "No proxy log found"
          echo ""
          echo "=== Mock Server Logs ==="
          cat /tmp/mock-server.log || echo "No mock server log found"
